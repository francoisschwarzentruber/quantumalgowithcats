<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>Quantum computing explained with cats</title>
	<script type="text/javascript" src="distribution.js"></script>
	<script type="text/javascript"
		src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
	<h1>Quantum computing explained with cats</h1>

	$$\newcommand{\ket}[1]{\mid#1 \rangle}$$

	<h2>Bits as cats</h2>
	A bit can be either 0 or 1. Let us represent them by cats:

	<example>
		bit = 0 <img class="qubit" src="cat1_dead.png"> </example>
	<example> bit = 1 <img class="qubit" src="cat1_alive.png"></example>

	<h2>Qubits</h2>
	Qubits are quantum bits. They are also represented by cats, but they can be in a superposed state. For instance:

	<example> <img class="qubit" src="cat1_dead.png"> is the qubit equal to 0. This state is denoted by |0>.</example>
	<example> <img class="qubit" src="cat1_alive.png"> is the qubit equal to |1>.</example>

	<example>
		<img class="qubit" id="example_superposition" src="cat1_dead.png"> may represent the superposition $$\frac 1
		{\sqrt 2} (\ket 0 +
		\ket 1)$$ where the qubit is at |0> with probability 1/2 and at |1> with probability 1/2.
	</example>


	<example>
		<img class="qubit" id="example_superposition_1434" src="cat1_dead.png"> may represent the superposition $$\frac
		1 2 \ket 0 + \frac
		{\sqrt 3} 2 \ket 1)$$ where the qubit is at |0> with probability 1/4 and at |1> with probability 3/4.
	</example>


	<h2>Two qubits</h2>

	<example>
		<img id="example_superposition_2_bit1" src="cat1_dead.png"><img id="example_superposition_2_bit2"
			src="cat2_dead.png"> may represent the superposition $$\frac 1 2 (\ket {00} + \ket {01} + \ket {10} + \ket
		{11})$$ where all states |00>, |01>, |10> and |11> have probability 1/4.
	</example>

	<example>
		<img id="example_superposition_bellstate_bit1" src="cat1_dead.png"><img
			id="example_superposition_bellstate_bit2" src="cat2_dead.png"> is a <a
			href="http://en.wikipedia.org/wiki/Bell_state">Bell state</a>: it may be the
		superposition $$\frac 1 {\sqrt 2} (\ket {00} + \ket {11})$$ where we have |00> with probability 1/2 and |11>
		with
		probability 1/2. There is <a href="https://en.wikipedia.org/wiki/Quantum_entanglement">entanglement</a>.
	</example>


	<h2>Note: in fact scalars (i.e. numbers) are complex numbers</h2>
	For instance, if the scalar is negative,
	images are turned.

	<example>
		<img src="cat1_alive_down.png"> may represent the superposition -|1>.
	</example>


	<h2>Hadamard gates</h2>

	<a href="https://en.wikipedia.org/wiki/Hadamard_transform">Hadamard gates</a> enables to compute uniform
	superposition of all physical states.

	<table>
		<tr>
			<td>
				<img class="qubit" src="cat1_dead.png">
			</td>
			<td>
				<img src="gateH.png"><br />
			</td>
			<td>
				<img class="qubit" id="example_superpositionH0" src="cat1_dead.png"><br />
			</td>
		</tr>
	</table>


	<table>
		<tr>
			<td>
				<img class="qubit" src="cat1_alive.png">
			</td>
			<td>
				<img src="gateH.png"><br />
			</td>
			<td>
				<img class="qubit" id="example_superpositionH1" src="cat1_dead.png"><br />
			</td>
		</tr>
	</table>


	<h2>The problem of finding a specific solution</h2>

	Let f be a
	function from \(\{0, 1\}^n\) to {0, 1}. Here n = 4. We pose \(N = 2^n\). Here N =
	16. There is a unique element x such that f(x) = 1.



	<example>In the rest of this paper, consider x = 0101 to be that unique element, i.e.

		<br />
		<img class="qubit" src="cat1_dead.png"><br />
		<img class="qubit" src="cat2_alive.png"><br />
		<img class="qubit" src="cat3_dead.png"><br />
		<img class="qubit" src="cat4_alive.png">.
	</example>

	The aim is to find x without any knowledge on f. More precisely, the problem that we will solve is defined
	as follows:
	<br />
	- input: a black box Uf that computes f;
	<br /> - output: x such that f(x) = 1.



	<h2>A gate for Uf</h2>

	The black box is constructed so that it preserves all physical states except |0101>, which is mapped to -|0101>.
	We suppose that \(U_f(x) = -x\) when f(x) = 1 and Uf(x) = x for all other x.


	<table>
		<tr>
			<td>
				<img class="qubit" src="cat1_dead.png"><br />
				<img class="qubit" src="cat2_alive.png"><br />
				<img class="qubit" src="cat3_dead.png"><br />
				<img class="qubit" src="cat4_alive.png">
			</td>
			<td>
				<img class="gatesize4" src="gatef.png">
			</td>
			<td>
				<img class="qubit" src="cat1_dead_down.png"><br />
				<img class="qubit" src="cat2_alive_down.png"><br />
				<img class="qubit" src="cat3_dead_down.png"><br />
				<img class="qubit" src="cat4_alive_down.png">
			</td>
		</tr>
	</table>

	For all other elements, the gate outputs its input.

	<table>
		<tr>
			<td>
				<img class="qubit" src="cat1_alive.png"><br />
				<img class="qubit" src="cat2_alive.png"><br />
				<img class="qubit" src="cat3_dead.png"><br />
				<img class="qubit" src="cat4_alive.png">
			</td>
			<td>
				<img class="gatesize4" src="gatef.png">
			</td>
			<td>
				<img class="qubit" src="cat1_alive.png"><br />
				<img class="qubit" src="cat2_alive.png"><br />
				<img class="qubit" src="cat3_dead.png"><br />
				<img class="qubit" src="cat4_alive.png">
			</td>
		</tr>
	</table>



	<table>
		<tr>
			<td>
				<img class="qubit" src="cat1_dead.png"><br />
				<img class="qubit" src="cat2_alive.png"><br />
				<img class="qubit" src="cat3_dead.png"><br />
				<img class="qubit" src="cat4_dead.png">
			</td>
			<td>
				<img class="gatesize4" src="gatef.png">
			</td>
			<td>
				<img class="qubit" src="cat1_dead.png"><br />
				<img class="qubit" src="cat2_alive.png"><br />
				<img class="qubit" src="cat3_dead.png"><br />
				<img class="qubit" src="cat4_dead.png">
			</td>
		</tr>
	</table>




	<h2>Grover's algorithm</h2>

	<a href="https://en.wikipedia.org/wiki/Grover's_algorithm">Grover's algorithm</a> solves the problem of finding a specific solution (see also <a href="https://xlinux.nist.gov/dads/HTML/groversAlgo.html">this link</a>).
	The circuit of that algorithm is as follows.
	Grover's starts with 0000.
	Then we apply Hadamar gates to obtain a uniform superposition of all physical states.
	We then repete a sequence of Uf and D (explained below).
	After an appropriate number of repetitions (not too many, not little), the probability to read our unique element is very high, see (*). 


	<table>
		<tbody>
			<tr>
				<td>
					<img class="qubit" id="superposition0_bit1" style="" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition0_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition0_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition0_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize1"  src="gateH.png"><br />
					<img class="gatesize1" src="gateH.png"><br />
					<img class="gatesize1" src="gateH.png"><br />
					<img class="gatesize1" src="gateH.png">
				</td>
				<td>
					<img class="qubit" id="superposition1_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition1_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition1_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition1_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gatef.png">
				</td>
				<td>
					<img class="qubit" id="superposition2_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition2_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition2_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition2_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gateD.png">
				</td>
				<td>
					<img class="qubit" id="superposition3_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition3_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition3_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition3_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gatef.png">
				</td>
				<td>
					<img class="qubit" id="superposition4_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition4_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition4_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition4_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gateD.png">
				</td>
				<td>
					<img class="qubit" id="superposition5_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition5_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition5_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition5_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gatef.png">
				</td>
				<td>
					<img class="qubit" id="superposition6_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition6_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition6_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition6_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gateD.png">
				</td>
				<td>
					(*)
					<img class="qubit" id="superposition7_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition7_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition7_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition7_bit4" src="cat4_alive.png"><br />
				</td>
				<td>
					<img class="gatesize4" src="gatef.png">
				</td>
				<td>
					<img class="qubit" id="superposition8_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition8_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition8_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition8_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img class="gatesize4" src="gateD.png">
				</td>
				<td>
					(**)
					<img class="qubit" id="superposition9_bit1" src="cat1_alive.png"><br />
					<img class="qubit" id="superposition9_bit2" src="cat2_alive.png"><br />
					<img class="qubit" id="superposition9_bit3" src="cat3_alive.png"><br />
					<img class="qubit" id="superposition9_bit4" src="cat4_alive.png"><br />
				</td>
			</tr>
		</tbody>
	</table>



	It remains to describe D and to see what is the optimal number of repetition of Uf D. Actually, D is the Grover diffusion
	operator that amplifies the unique state that has a negative scalar and put a positive scalar on it that is stricly
	greater in norm that the previous scalar. The other states are such that their probability are lower. In other
	words, the state |0101> is amplified.
	When we then apply again the Uf operator, we continue to negate the scalar of |0101> and the other scalars are kept
	equal. Then D continues to amply more and more the scalar of |0101> in norm.
	After some iterations of Uf
	and D, we may measure the qubits and obtain |0101> with a probability
	higher than 1/2: at (*) in the circuit the measure is ideal.

	<script>
		// frames per second
		var FPS = 10;

		// Returns a superposition of 4 qubits where each state has probability 1/rac 16
		function generateHnsuperposition() {
			superposition = new Distribution();
			for (var b1 = 0; b1 <= 1; b1++)
				for (var b2 = 0; b2 <= 1; b2++)
					for (var b3 = 0; b3 <= 1; b3++)
						for (var b4 = 0; b4 <= 1; b4++)
							superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: 1 / 16 }, 1 / 16);

			return superposition;
		}

		// the unique element x such that f(x) = 1
		var magicElement = { bit1: 0, bit2: 1, bit3: 0, bit4: 1 };

		// generate the state where the magic Element is weighted by a and other elements are weighted by b
		function generateStateWithMagicElement(a, b) {
			superposition = new Distribution();
			for (var b1 = 0; b1 <= 1; b1++)
				for (var b2 = 0; b2 <= 1; b2++)
					for (var b3 = 0; b3 <= 1; b3++)
						for (var b4 = 0; b4 <= 1; b4++) {
							if ((b1 == magicElement.bit1) &&
								(b2 == magicElement.bit2) &&
								(b3 == magicElement.bit3) &&
								(b4 == magicElement.bit4))
								superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: a }, Math.pow(a, 2));
							else {
								superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: b }, Math.pow(b, 2));

							}
						}

			return superposition;
		}


		// generate the superposition where the state is completely determined (its weight = 1)
		function generateSuperpositionUniqueState(b1, b2, b3, b4) {
			superposition = new Distribution([]);
			superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: 1 }, 1);
			return superposition;
		}

		// parameters of Grover's algorithm
		var N = 16; //2^(nb of qubits)
		var theta = Math.asin(1 / Math.sqrt(N));

		// a(k) and b(k) are the weight of respectively the magic element and the others elements in the superpositions of the Grover's algorithm
		function a(k) {
			return Math.sin((2 * k + 1) * theta);
		}

		function b(k) {
			return (1 / Math.sqrt(N - 1)) * Math.cos((2 * k + 1) * theta);
		}

		//alert(a(0));
		//alert(b(0));

		// the superpositions in the circuit
		var superpositions = new Array();
		superpositions[0] = generateSuperpositionUniqueState(0, 0, 0, 0);
		superpositions[1] = generateHnsuperposition();
		superpositions[2] = generateStateWithMagicElement(-a(0), b(0));
		superpositions[3] = generateStateWithMagicElement(a(1), b(1));
		superpositions[4] = generateStateWithMagicElement(-a(1), b(1));
		superpositions[5] = generateStateWithMagicElement(a(2), b(2));
		superpositions[6] = generateStateWithMagicElement(-a(2), b(2));
		superpositions[7] = generateStateWithMagicElement(a(3), b(3));
		superpositions[8] = generateStateWithMagicElement(-a(3), b(3));
		superpositions[9] = generateStateWithMagicElement(a(4), b(4));

		function randomBit() {
			return Math.random() < 0.5;
		}


		// returns "_down" if the weight of the state is negative and "" else
		function downifnegative(state) { return (state.alpha < 0) ? "_down" : ""; }
		function getAliveOrDead(bit) { return bit ? "_alive" : "_dead"; }

		// the loop of the animation
		function loop() {
			// we update all the superpositions in the circuit
			for (var i = 0; i <= 9; i++) {
				state = superpositions[i].peekRandom();

				window.document.getElementById("superposition" + i + "_bit1").src =
					"cat1" + getAliveOrDead(state.bit1) + downifnegative(state) + ".png";
				window.document.getElementById("superposition" + i + "_bit2").src =
					"cat2" + getAliveOrDead(state.bit2) + downifnegative(state) + ".png";
				window.document.getElementById("superposition" + i + "_bit3").src =
					"cat3" + getAliveOrDead(state.bit3) + downifnegative(state) + ".png";
				window.document.getElementById("superposition" + i + "_bit4").src =
					"cat4" + getAliveOrDead(state.bit4) + downifnegative(state) + ".png";

			}

			// we update the superpositions in the explanation
			document.getElementById("example_superposition").src = "cat1" + getAliveOrDead(Math.random() < 0.5) + ".png";
			document.getElementById("example_superpositionH0").src = "cat1" + getAliveOrDead(Math.random() < 0.5) + ".png";
			{
				const b = randomBit();
				if(b)
				document.getElementById("example_superpositionH1").src = "cat1" + getAliveOrDead(1) + "_down" + ".png";
				else
				document.getElementById("example_superpositionH1").src = "cat1" + getAliveOrDead(0) + ".png";
			}

			window.document.getElementById("example_superposition_1434").src = "cat1" + getAliveOrDead(Math.random() < 0.75) + ".png";

			var b = Math.random() < 0.5;
			window.document.getElementById("example_superposition_bellstate_bit1").src = "cat1" + getAliveOrDead(b) + ".png";
			window.document.getElementById("example_superposition_bellstate_bit2").src = "cat2" + getAliveOrDead(b) + ".png";

			window.document.getElementById("example_superposition_2_bit1").src = "cat1" + getAliveOrDead(Math.random() < 0.5) + ".png";
			window.document.getElementById("example_superposition_2_bit2").src = "cat2" + getAliveOrDead(Math.random() < 0.5) + ".png";
			setTimeout("loop()", 1000 / FPS);
		}

		loop();
	</script>

</body>

</html>
